<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Point Cloud Viewer with Semantics</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: monospace;
      background: #000;
      color: #0f0;
      display: flex;
      height: 100vh;
    }
    #canvas-container {
      flex: 1;
      position: relative;
    }
    #side {
      width: 280px;
      background: #111;
      padding: 12px;
      overflow-y: auto;
    }
    #side h3 {
      margin: 0 0 10px;
      color: #0f0;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 8px;
    }
    #ctrl {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 4px;
    }
    button {
      background: #0f0;
      color: #000;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      margin-right: 8px;
      border-radius: 3px;
      font-family: monospace;
    }
    button:hover {
      background: #0c0;
    }
    button.active {
      background: #ff0;
      color: #000;
    }
    input[type="range"] {
      width: 300px;
      vertical-align: middle;
    }
    .info-row {
      margin: 4px 0;
      font-size: 12px;
    }
    #objectList {
      font-size: 11px;
      max-height: 300px;
      overflow-y: auto;
    }
    .object-item {
      padding: 3px 0;
      border-bottom: 1px solid #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .object-item .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 6px;
      border: 1px solid #555;
    }
  </style>
</head>
<body>
<div id="canvas-container">
  <div id="info">åŠ è½½ä¸­...</div>
  <div id="ctrl">
    <button id="playBtn">æ’­æ”¾</button>
    <button id="colorModeBtn">è¯­ä¹‰é¢œè‰²</button>
    <input type="range" id="timeSlider" min="0" max="100" value="0">
    <span id="frameInfo">0 / 0</span>
  </div>
</div>

<div id="side">
  <h3>ç‚¹äº‘ä¿¡æ¯</h3>
  <div id="statsPanel"></div>

  <h3 style="margin-top: 16px">åœºæ™¯ç‰©ä½“</h3>
  <div id="objectList">æœªåŠ è½½ç‰©ä½“æ˜ å°„</div>

  <h3 style="margin-top: 16px">æ§åˆ¶</h3>
  <div class="info-row">
    <label>ç‚¹å¤§å°: <input type="range" id="pointSize" min="0.001" max="0.01" step="0.001" value="0.003"></label>
    <span id="pointSizeVal">0.003</span>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
const EP_ID = 0;  // ä¿®æ”¹episodeå·
const META_URL = `pointmeta_ep_${EP_ID}.json`;
const FRAMES_URL = `pointframes_ep_${EP_ID}.json`;


let meta, frames, geomMapping = {};
let scene, camera, renderer, pointsObj;
let playing = false, curFrame = 0;
let useSemanticColor = false;  // é¢œè‰²æ¨¡å¼åˆ‡æ¢


/* åˆå§‹åŒ–åœºæ™¯ */
async function loadJson(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`${url} æœªæ‰¾åˆ°`);
  return res.json();
}

function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const aspect = (innerWidth - 280) / innerHeight;
  camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 100);
  camera.position.set(1.5, 1.5, 1.5);
  camera.lookAt(0, 0.8, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth - 280, innerHeight);
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  // ç…§æ˜
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));

  // å‚è€ƒç½‘æ ¼
  const grid = new THREE.GridHelper(2, 20, 0x444444, 0x222222);
  grid.position.y = 0;
  scene.add(grid);

  // åæ ‡è½´
  const axes = new THREE.AxesHelper(0.5);
  scene.add(axes);

  addMouseControl();
}

function addMouseControl() {
  let mouseDown = false;
  let lastX = 0, lastY = 0;
  let theta = 0, phi = Math.PI / 4;
  const radius = 2.5;

  renderer.domElement.addEventListener('mousedown', e => {
    mouseDown = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  window.addEventListener('mouseup', () => mouseDown = false);

  window.addEventListener('mousemove', e => {
    if (!mouseDown) return;

    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    theta -= dx * 0.01;
    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + dy * 0.01));

    camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
    camera.position.y = radius * Math.cos(phi) + 0.8;
    camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
    camera.lookAt(0, 0.8, 0);
  });

  // ç¼©æ”¾
  renderer.domElement.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 1.1 : 0.9;
    camera.position.multiplyScalar(factor);
  });
}

/* æ¸²æŸ“ç‚¹äº‘ */
let labelColors = {};
function buildFrame(idx) {
  const frame = frames[idx];

  if (pointsObj) {
    scene.remove(pointsObj);
    pointsObj.geometry.dispose();
    pointsObj.material.dispose();
  }

  // åæ ‡è½¬æ¢
  const positions = new Float32Array(frame.points.length * 3);
  for (let i = 0; i < frame.points.length; i++) {
    const [mx, my, mz] = frame.points[i];
    positions[i * 3 + 0] = mx;
    positions[i * 3 + 1] = mz;
    positions[i * 3 + 2] = my;
  }

  // ğŸ”¥ æ ¹æ®æ¨¡å¼é€‰æ‹©é¢œè‰²æ•°ç»„
  const colorSource = useSemanticColor ? frame.colors_seg : frame.colors_rgb;

  const colors = new Float32Array(colorSource.length * 3);
  for (let i = 0; i < colorSource.length; i++) {
    colors[i * 3 + 0] = colorSource[i][0] / 255;
    colors[i * 3 + 1] = colorSource[i][1] / 255;
    colors[i * 3 + 2] = colorSource[i][2] / 255;
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const pointSize = parseFloat(document.getElementById('pointSize').value);
  const material = new THREE.PointsMaterial({
    size: pointSize,
    vertexColors: true,
    sizeAttenuation: true
  });

  pointsObj = new THREE.Points(geometry, material);
  scene.add(pointsObj);

  document.getElementById('frameInfo').textContent = `${idx + 1} / ${frames.length}`;
  updateStats(frame);
}

function updateStats(frame) {
  const stats = document.getElementById('statsPanel');
  stats.innerHTML = `
    <div class="info-row">æ—¶é—´æˆ³: ${frame.timestamp.toFixed(2)}s</div>
    <div class="info-row">æ­¥éª¤: ${frame.step_idx}</div>
    <div class="info-row">ç‚¹æ•°: ${frame.points.length.toLocaleString()}</div>
    <div class="info-row">é¢œè‰²æ¨¡å¼: ${useSemanticColor ? 'è¯­ä¹‰åˆ†å‰²' : 'RGBåŸè‰²'}</div>
  `;

  if (frame.labels && Object.keys(siteMapping).length > 0) {
    const uniqueIds = [...new Set(frame.labels)];
    const objectList = document.getElementById('objectList');

    // ğŸ”¥ è®¡ç®—æ¯ä¸ªlabelçš„å¹³å‡é¢œè‰²ï¼ˆä»å¯¹åº”çš„é¢œè‰²æ•°ç»„ï¼‰
    const colorSource = useSemanticColor ? frame.colors_seg : frame.colors_rgb;
    const labelColors = {};
    for (let i = 0; i < frame.labels.length; i++) {
      const label = frame.labels[i];
      if (!labelColors[label]) {
        labelColors[label] = { r: 0, g: 0, b: 0, count: 0 };
      }
      labelColors[label].r += colorSource[i][0];
      labelColors[label].g += colorSource[i][1];
      labelColors[label].b += colorSource[i][2];
      labelColors[label].count += 1;
    }

    let html = `<div class="info-row" style="color: #0f0; margin-bottom: 8px;">
      æ£€æµ‹åˆ° ${uniqueIds.length} ä¸ªç‰©ä½“
    </div>`;

    uniqueIds.sort((a, b) => {
      const countA = frame.labels.filter(l => l === a).length;
      const countB = frame.labels.filter(l => l === b).length;
      return countB - countA;
    });

    uniqueIds.forEach(id => {
      const name = siteMapping[id] || `Unknown(${id})`;
      const count = frame.labels.filter(l => l === id).length;

      // ğŸ”¥ ä½¿ç”¨è¯¥labelçš„å¹³å‡é¢œè‰²
      const c = labelColors[id];
      const avgR = Math.floor(c.r / c.count);
      const avgG = Math.floor(c.g / c.count);
      const avgB = Math.floor(c.b / c.count);
      const colorHex = `rgb(${avgR}, ${avgG}, ${avgB})`;

      const isImportant = name.includes('plate') || name.includes('gripper') ||
                          name.includes('mug');
      const style = isImportant ? 'color: #ff0; font-weight: bold;' : 'color: #aaa;';

      html += `
        <div class="object-item">
          <div>
            <span class="color-box" style="background: ${colorHex}"></span>
            <span style="${style}">${name}</span>
          </div>
          <span style="color: #666;">${count}ç‚¹</span>
        </div>
      `;
    });

    objectList.innerHTML = html;
  }
}

/* æ’­æ”¾æ§åˆ¶ */
function animate() {
  requestAnimationFrame(animate);

  if (playing) {
    curFrame = (curFrame + 1) % frames.length;
    buildFrame(curFrame);
    document.getElementById('timeSlider').value = curFrame;
  }

  renderer.render(scene, camera);
}

/* ä¸»å…¥å£ */
(async () => {
  try {
    meta = await loadJson(META_URL);
    frames = await loadJson(FRAMES_URL);

    // ğŸ”¥ ä»metadataè¯»å–siteæ˜ å°„
    siteMapping = meta.site_mapping || {};
    console.log('âœ“ å·²åŠ è½½ç‰©ä½“æ˜ å°„:', Object.keys(siteMapping).length, 'ä¸ªsite');

    initScene();
    buildFrame(0);

    document.getElementById('info').textContent =
      `Episode ${meta.episode_id} | ${frames.length} å¸§ | ${meta.cameras.join(', ')}`;


    // æ—¶é—´è½´æ§åˆ¶
    document.getElementById('timeSlider').max = frames.length - 1;
    document.getElementById('timeSlider').addEventListener('input', e => {
      curFrame = parseInt(e.target.value);
      buildFrame(curFrame);
    });

    // æ’­æ”¾/æš‚åœæŒ‰é’®
    document.getElementById('playBtn').addEventListener('click', () => {
      playing = !playing;
      document.getElementById('playBtn').textContent = playing ? 'æš‚åœ' : 'æ’­æ”¾';
    });

    // é¢œè‰²æ¨¡å¼åˆ‡æ¢æŒ‰é’®
    const colorModeBtn = document.getElementById('colorModeBtn');
    colorModeBtn.addEventListener('click', () => {
      useSemanticColor = !useSemanticColor;
      colorModeBtn.textContent = useSemanticColor ? 'RGBé¢œè‰²' : 'è¯­ä¹‰é¢œè‰²';
      colorModeBtn.classList.toggle('active', useSemanticColor);
      buildFrame(curFrame);
    });

    // ç‚¹å¤§å°æ§åˆ¶
    document.getElementById('pointSize').addEventListener('input', e => {
      document.getElementById('pointSizeVal').textContent = e.target.value;
      buildFrame(curFrame);
    });

    animate();
  } catch (error) {
    document.getElementById('info').textContent = `åŠ è½½å¤±è´¥: ${error.message}`;
    console.error(error);
  }
})();
</script>
</body>
</html>
